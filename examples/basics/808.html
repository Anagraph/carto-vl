<!DOCTYPE html>
<html>
<head>
  <title> CARTO-Rhythm-VL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <script src="../../dist/carto-vl.js"></script>
  <script src="https://cartodb-libs.global.ssl.fastly.net/mapbox-gl/v0.44.1-carto1/mapbox-gl.js"></script>
  <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #map {
      position: absolute;
      height: 100%;
      width: 100%;
    }
    #story {
      position: absolute;
      top: '20px', left: '20px';
      color: gray;
      font-family: Arial;
      font-size: 35pt;
      opacity: 0.2;
      overflow:visible;
      pointer-events:none;
      background:none !important;
      padding: 1em;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="story">
    1972: EKO ComputeRhythm is the first programmable drum machine,
    stting the path for the immensely popular TR 808 and the expensive Linn's of the 80s,
    innumerable step sequencer programs and devices to come, thousands of apps, plugins, pedals and whatnot.
    But now, 45 years later, for the first time ever, the first video game speed (60 solid fps) drum machine,
    the amaxing CARTO-Rhythm-VL!!
  </div>
  <script>
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const sounds = [
    'bass_drum.wav', 'snare_drum.wav', 'cl_hi_hat.wav',
    'low_tom.wav', 'mid_tom.wav', 'hi_tom.wav',
    'rim_shot.wav', 'cowbell.wav', 'low_conga.wav', 'mid_conga.wav',
  ].map(s => 'https://blog.omgmog.net/beatmaker/sounds/' + s);

  const context = new AudioContext();
  const buffers = {};

  function playInst(inst) {
    const url = sounds[inst - 1];
    let audio = buffers[url];
    if (audio) {
      playBuffer(audio);
    }
    else {
      fetch(url).then(response => {
        if (response.status === 200) {
          response.arrayBuffer().then(buffer => {
            context.decodeAudioData(buffer)
            .then(audio => {
              buffers[url] = audio;
              playBuffer(audio);
            })
          });
        }
      });
    }
  };

  function playBuffer(buffer) {
    const source = context.createBufferSource();
    source.buffer = buffer;
    source.connect(context.destination);
    source.start();
  };

  const map = new mapboxgl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: {},
      layers: [
        {
          id: 'background',
          type: 'background',
          paint: { 'background-color': 'black' }
        }
      ]
    },
    center: [4, 5],
    zoom: 5,
    dragRotate: false
  });

  const nSteps = 16;
  const nInst = sounds.length;

  const source = new carto.source.GeoJSON(generateData(nSteps, nInst));
  function generateData(nSteps, nInst) {
      const features = [];
      const dx = 0.45;
      const dy = 0.9;
      const x0 = 0;
      const y0 = 0;
      let id = 1;
      for (let step = 1; step <= nSteps; ++step) {
        for (let inst = 1; inst <= nInst; ++inst) {
          features.push({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [step*dx + x0, inst*dy + y0]
            },
            properties: {
              cartodb_id: id++,
              inst,
              step
            }
          });
        }
      }
      return { type: 'FeatureCollection', features };
  }

  const palettes = ['ANTIQUE', 'BOLD', 'PASTEL', 'PRISM', 'SAFE', 'VIVID'];
  const s = carto.expressions;
  const palette = s.palettes[palettes[Math.floor(Math.random()*palettes.length)]];
  let bpm = new URL(location.href).searchParams.get('bpm') || 120;
  const duration = nSteps/4*60/bpm;
  const steps = s.linear(s.prop('step'), 0, nSteps);
  const cycle = s.torque(steps, duration, s.fade(duration/nSteps/2, duration/nSteps/2));
  const pulse = f => s.torque(0.5, duration/nSteps/f, s.fade(duration/nSteps/2/f, duration/nSteps/2/f));
  let op = s.add(0.75, s.div(s.mod(s.add(1,s.floor(s.div(s.sub(s.prop('step'),1),4))),2),4));
  op = s.add(s.div(op, 2), s.div(cycle, 2));
  const size = (sz, p, f) => s.add(s.mul(sz,s.zoom()), s.mul(p, pulse(f)));
  const offSize = () => size(0.8, 5, 0.25);
  const onSize = () => size(1.4, 20, 1);
  let viz = new carto.Viz({
      variables: {
        inst: s.prop('inst'),
        step: s.prop('step'),
      },
      strokeWidth: 0,
      color: s.opacity(s.ramp(s.div(s.sub(s.prop('inst'),1),nInst-1),palette), op),
      width: offSize()
  });
  const pattern = {};
  const layer = new carto.Layer('layer', source, viz);
  layer.addTo(map, 'background');
  const interactivity = new carto.Interactivity(layer);
  interactivity.on('featureClick', featureEvent => {
    const feature = featureEvent.features[0];
    if (feature) {
      const inst = feature.variables.inst.value;
      const step = feature.variables.step.value;
      if (!pattern[step]) {
          pattern[step] = {};
      }
      pattern[step][inst] = pattern[step][inst] || false;
      pattern[step][inst] = !pattern[step][inst];
      const state = pattern[step][inst];
      const width = state ? onSize() : offSize();
      feature.width.blendTo(width, 100);
    }
  });
  const tol = 1E-1;
  function tick() {
      const t = cycle.getSimTime();
      let nearStep = Math.round(t) % nSteps;
      const err = duration*Math.abs((t - nearStep)/nSteps);
      let nextStep = nearStep + 1;
      if (nearStep === 0) {
        nearStep = nSteps;
      }
      if (err < tol) {
          if (pattern[nearStep]) {
            Object.keys(pattern[nearStep]).forEach(inst => {
              if (pattern[nearStep][inst]) {
                playInst(inst);
              }
            });
          }
      }
      else {
        nextStep = Math.ceil(t);
        if (nextStep === 0) {
            nextStep = nSteps;
        }
      }
      const dt = 1000*((nextStep - t)/nSteps)*duration;
      setTimeout(tick, dt);
  }
  tick();
  </script>
</body>
</html>
