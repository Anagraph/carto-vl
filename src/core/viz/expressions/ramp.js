import BaseExpression from './base';
import { implicitCast, checkLooseType, checkExpression, checkType, clamp, checkInstance } from './utils';
import { cielabToSRGB, sRGBToCielab } from '../colorspaces';
import Sprites from './sprites';
import { NamedColor } from './color/NamedColor';

const paletteTypes = {
    PALETTE: 'palette',
    COLOR_ARRAY: 'color-array',
    NUMBER_ARRAY: 'number-array',
    SPRITE: 'sprite'
};

const rampTypes = {
    COLOR: 'color',
    NUMBER: 'number'
};

const inputTypes = {
    NUMBER: 'number',
    CATEGORY: 'category'
};

const COLOR_ARRAY_LENGTH = 256;
const COLOR_VALUES = COLOR_ARRAY_LENGTH - 1;


/**
* Create a ramp: a mapping between an input (a numeric or categorical expression) and an output (a color palette or a numeric palette, to create bubble maps)
*
* Categories to colors
* Categorical expressions can be used as the input for `ramp` in combination with color palettes. If the number of categories exceeds the number of available colors in the palette new colors will be generated by
* using CieLAB interpolation.
*
* Categories to numeric
* Categorical expression can be used as the input for `ramp` in combination with numeric palettes. If the number of input categories doesn't match the number of numbers in the numeric palette, linear interpolation will be used.
*
* Numeric expressions to colors
* Numeric expressions can be used as the input for `ramp` in combination with color palettes. Colors will be generated by using CieLAB interpolation.
*
* Numeric expressions to numeric
* Numeric expressions can be used as the input for `ramp` in combination with numeric palettes. Linear interpolation will be used to generate intermediate output values.
*
* @param {Number|Category} input - The input expression to give a color
* @param {Palette|Color[]|Number[]} palette - The color palette that is going to be used
* @return {Number|Color}
*
* @example <caption>Mapping categories to colors and numbers</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), [1, 4, 8])
*   color: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), s.palettes.PRISM)
* });
*
* @example <caption>Mapping categories to colors and numbers (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(buckets($dn, [20, 50, 120]), [1, 10,4])
*   color: ramp(buckets($dn, [20, 50, 120]), prism)
* `);
*
*
* @example <caption>Mapping numeric expressions to colors and numbers</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.linear(s.prop('dn'), 40, 100), [1, 8])
*   color: s.ramp(s.linear(s.prop('dn'), 40, 100), s.palettes.PRISM)
* });
*
* @example <caption>Mapping numeric expressions to colors and numbers (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(linear($dn, 40, 100), [1, 10,4])
*   color: ramp(linear($dn, 40, 100), prism)
* `);
*
* @memberof carto.expressions
* @name ramp
* @function
* @api
*/
export default class Ramp extends BaseExpression {
    constructor(input, palette) {
        input = implicitCast(input);
        palette = implicitCast(palette);

        checkExpression('ramp', 'input', 0, input);
        checkLooseType('ramp', 'input', 0, Object.values(inputTypes), input);
        checkLooseType('ramp', 'palette', 1, Object.values(paletteTypes), palette);
        
        if (palette.type === paletteTypes.SPRITE) {
            checkInstance('ramp', 'palette', 1, Sprites, palette);
            checkLooseType('ramp', 'input', 0, inputTypes.CATEGORY, input);
        }

        super({ input: input });
        this.minKey = 0;
        this.maxKey = 1;
        this.palette = palette;
        this.type = palette.type === paletteTypes.NUMBER_ARRAY ? rampTypes.NUMBER : rampTypes.COLOR;
        this.defaultOtherColor = new NamedColor('gray');
        
        try {
            if (palette.type === paletteTypes.NUMBER_ARRAY) {
                this.palette.floats = this.palette.eval();
            } else if (palette.type === paletteTypes.COLOR_ARRAY) {
                this.palette.colors = this.palette.eval();
            }
        } catch (error) {
            throw new Error('Palettes must be formed by constant expressions, they cannot depend on feature properties');
        }
    }

    loadSprites() {
        return Promise.all([this.input.loadSprites(), this.palette.loadSprites()]);
    }

    _setUID(idGenerator) {
        super._setUID(idGenerator);
        this.palette._setUID(idGenerator);
    }

    eval(feature) {
        const colorValues = this._computeTextureIfNeeded();
        const input = this.input.eval(feature);
        const numColorValues = colorValues.length - 1;
        const m = input / this.maxKey;

        return this.palette.type === paletteTypes.NUMBER_ARRAY
            ? this._getColorValue(colorValues, numColorValues, m)
            : this._getRGBAColorValue(colorValues, m);
    }

    _getColorValue(colorValues, numColorValues, m) {
        const lowIndex = clamp(Math.floor(numColorValues * m), 0, numColorValues);
        const highIndex = clamp(Math.ceil(numColorValues * m), 0, numColorValues);
        const fract = numColorValues * m - Math.floor(numColorValues * m);
        const low = colorValues[lowIndex];
        const high = colorValues[highIndex];

        return Math.round(fract * high + (1 - fract) * low);
    }
    
    _getRGBAColorValue(colorValues, m) {
        const index = Math.round(m * COLOR_VALUES);

        return {
            r: Math.round(colorValues[index * 4 + 0]),
            g: Math.round(colorValues[index * 4 + 1]),
            b: Math.round(colorValues[index * 4 + 2]),
            a: Math.round(colorValues[index * 4 + 3]) / COLOR_VALUES
        };
    }
    
    _compile(meta) {
        super._compile(meta);
        checkType('ramp', 'input', 0, Object.values(inputTypes), this.input);
        
        if (this.palette.type === paletteTypes.SPRITE) {
            checkType('ramp', 'input', 0, inputTypes.CATEGORY, this.input);
            checkInstance('ramp', 'palette', 1, Sprites, this.palette);
        }

        this._texCategories = null;
        this._GLtexCategories = null;
    }

    _free(gl) {
        if (this.texture) {
            gl.deleteTexture(this.texture);
        }
    }

    _applyToShaderSource(getGLSLforProperty) {
        const input = this.input._applyToShaderSource(getGLSLforProperty);

        if (this.palette.type === paletteTypes.SPRITE) {
            const sprites = this.palette._applyToShaderSource(getGLSLforProperty);
            
            return {
                preface: input.preface + sprites.preface,
                inline: `${sprites.inline}(spriteUV, ${input.inline})`
            };
        }
    
        return { 
            preface: this._prefaceCode(
                input.preface + `
                uniform sampler2D texRamp${this._uid};
                uniform float keyMin${this._uid};
                uniform float keyWidth${this._uid};`
            ),
            
            inline: this.palette.type === paletteTypes.NUMBER_ARRAY
                ? `(texture2D(texRamp${this._uid}, vec2((${input.inline}-keyMin${this._uid})/keyWidth${this._uid}, 0.5)).a)`
                : `texture2D(texRamp${this._uid}, vec2((${input.inline}-keyMin${this._uid})/keyWidth${this._uid}, 0.5)).rgba`
        };
    }
    
    _getColorsFromPalette(input, palette) {
        if (palette.type === paletteTypes.SPRITE) {
            return palette.colors;
        }

        return palette.type === paletteTypes.PALETTE
            ? this._getColorsFromPaletteType(input, palette)
            : this._getColorsFromColorArrayType(palette);
    }

    _getColorsFromPaletteType (input, palette) {
        let colors = input.numCategories
            ? this._getSubPalettes(input, palette)
            : palette.getLongestSubPalette();

        return _needsToRemoveOtherCategory(input, palette, colors)
            ? _removeOtherFromColors(colors)
            : colors;
    }

    _getColorsFromColorArrayType (palette) {
        return this.maxKey >= palette.colors.length
            ? _addOtherColorToColors(palette.colors, this.defaultOtherColor.eval())
            : palette.colors;
    }

    _getSubPalettes(input, palette) {
        const subPaletteNumber = palette.isQualitative() && !input.isCategoryType
            ? input.numCategories
            : this.maxKey;

        return palette.subPalettes[subPaletteNumber]
            ? palette.subPalettes[subPaletteNumber]
            : palette.getLongestSubPalette();
    }
    
    _postShaderCompile(program, gl) {
        if (this.palette.type === paletteTypes.SPRITE) {
            this.palette._postShaderCompile(program, gl);
            super._postShaderCompile(program, gl);
            return;
        }

        this.input._postShaderCompile(program, gl);
        this._getBinding(program).texLoc = gl.getUniformLocation(program, `texRamp${this._uid}`);
        this._getBinding(program).keyMinLoc = gl.getUniformLocation(program, `keyMin${this._uid}`);
        this._getBinding(program).keyWidthLoc = gl.getUniformLocation(program, `keyWidth${this._uid}`);
    }

    _computeTextureIfNeeded() {
        if (this._texCategories !== this.input.numCategories) {
            this._texCategories = this.input.numCategories;

            if (this.input.type === inputTypes.CATEGORY) {
                this.maxKey = this.input.numCategories - 1;
            }

            const colorValues = this.type === rampTypes.COLOR
                ? this._computeTextureColor()
                : this._computeTexture();

            return colorValues;
        }

        return [];
    }

    _computeTextureColor() {
        const colorValues = new Uint8Array(4 * COLOR_ARRAY_LENGTH);
        const colors = this._getColorsFromPalette(this.input, this.palette);
        
        for (let i = 0; i < COLOR_ARRAY_LENGTH; i++) {
            const vlowRaw = colors[Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1))];
            const vhighRaw = colors[Math.ceil(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1))];
            const vlow = [vlowRaw.r / COLOR_VALUES, vlowRaw.g / COLOR_VALUES, vlowRaw.b / COLOR_VALUES, vlowRaw.a];
            const vhigh = [vhighRaw.r / COLOR_VALUES, vhighRaw.g / COLOR_VALUES, vhighRaw.b / COLOR_VALUES, vhighRaw.a];
            const m = i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1) - Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1));
            const v = interpolate({ r: vlow[0], g: vlow[1], b: vlow[2], a: vlow[3] }, { r: vhigh[0], g: vhigh[1], b: vhigh[2], a: vhigh[3] }, m);

            colorValues[4 * i + 0] = Math.round(v.r * COLOR_VALUES);
            colorValues[4 * i + 1] = Math.round(v.g * COLOR_VALUES);
            colorValues[4 * i + 2] = Math.round(v.b * COLOR_VALUES);
            colorValues[4 * i + 3] = Math.round(v.a * COLOR_VALUES);
        }

        return colorValues;
    }

    _computeTexture() {
        const colorValues = new Float32Array(COLOR_VALUES);
        const floats = this.palette.floats;

        for (let i = 0; i < COLOR_ARRAY_LENGTH; i++) {
            const vlowRaw = floats[Math.floor(i / COLOR_VALUES * (floats.length - 1))];
            const vhighRaw = floats[Math.ceil(i / COLOR_VALUES * (floats.length - 1))];
            const m = i / COLOR_VALUES * (floats.length - 1) - Math.floor(i / COLOR_VALUES * (floats.length - 1));
            colorValues[i] = ((1. - m) * vlowRaw + m * vhighRaw);
        }

        return colorValues;
    }

    _computeGLTextureIfNeeded(gl) {
        const colorValues = this._computeTextureIfNeeded();

        if (this._GLtexCategories !== this.input.numCategories) {
            this._GLtexCategories = this.input.numCategories;

            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);

            if (this.type === rampTypes.COLOR) {
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, COLOR_ARRAY_LENGTH, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, colorValues);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, COLOR_ARRAY_LENGTH, 1, 0, gl.ALPHA, gl.FLOAT, colorValues);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
    }

    _preDraw(program, drawMetadata, gl) {
        this.input._preDraw(program, drawMetadata, gl);

        if (this.palette.type === paletteTypes.SPRITE) {
            this.palette._preDraw(program, drawMetadata, gl);
            return;
        }

        gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);
        this._computeGLTextureIfNeeded(gl);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.uniform1i(this._getBinding(program).texLoc, drawMetadata.freeTexUnit);
        gl.uniform1f(this._getBinding(program).keyMinLoc, (this.minKey));
        gl.uniform1f(this._getBinding(program).keyWidthLoc, (this.maxKey) - (this.minKey));
        drawMetadata.freeTexUnit++;
    }
}

function interpolate(low, high, m) {
    const cielabLow = sRGBToCielab({
        r: low.r,
        g: low.g,
        b: low.b,
        a: low.a,
    });

    const cielabHigh = sRGBToCielab({
        r: high.r,
        g: high.g,
        b: high.b,
        a: high.a,
    });

    const cielabInterpolated = {
        l: (1 - m) * cielabLow.l + m * cielabHigh.l,
        a: (1 - m) * cielabLow.a + m * cielabHigh.a,
        b: (1 - m) * cielabLow.b + m * cielabHigh.b,
        alpha: (1 - m) * cielabLow.alpha + m * cielabHigh.alpha,
    };

    return cielabToSRGB(cielabInterpolated);
}

function _removeOtherFromColors (colors) {
    return colors.slice(0, colors.length - 1);
}

function _addOtherColorToColors (colors, otherColor) {
    return [...colors, otherColor];
}

function _needsToRemoveOtherCategory (input, palette, colors) {
    return palette.isQualitative() && 
    !input.isCategoryType &&
    (input.numCategories - 1) >= colors.length;
}
