import AggregationFiltering from './filtering/AggregationFiltering';
import PreaggregationFiltering from './filtering/AggregationFiltering';

/**
 * Returns supported windshaft filters for the viz
 * @param {*} viz
 * @returns {Filtering}
 */
export function getFiltering (viz, options = {}) {
    const aggrFiltering = new AggregationFiltering(options);
    const preFiltering = new PreaggregationFiltering(options);
    const filtering = {
        preaggregation: preFiltering.getFilter(viz.filter),
        aggregation: aggrFiltering.getFilters(viz.filter)
    };
    if (!filtering.preaggregation && !filtering.aggregation) {
        return null;
    }
    return filtering;
}

/**
 * Convert preaggregation filters (as generated by PreaggregationFiltering)
 * into an equivalent SQL WHERE expression.
 *
 * @param {Filtering} filtering
 */
export function getSQLWhere (filtering) {
    filtering = filtering && filtering.preaggregation;
    let sql;
    if (filtering && Object.keys(filtering).length > 0) {
        sql = getSQL(filtering);
    }
    return sql ? 'WHERE ' + sql : '';
}

export function getAggregationFilters (filtering) {
    return filtering && filtering.aggregation;
}

function getSQL (node) {
    if (node.type) {
        return `(${SQLGenerators[node.type](node)})`;
    }
    return sqlQ(node);
}

function sqlQ (value) {
    if (isFinite(value)) {
        return String(value);
    }
    return `'${value.replace(/\'/g, '\'\'')}'`;
}

function sqlId (id) {
    if (!id.match(/^[a-z\d_]+$/)) {
        id = `"${id.replace(/\"/g, '""')}"`;
    }
    return id;
}

function sqlSep (sep, ...args) {
    return args.map(arg => getSQL(arg)).join(sep);
}

const SQLGenerators = {
    'and': f => sqlSep(' AND ', f.left, f.right),
    'or': f => sqlSep(' OR ', f.left, f.right),
    'between': f => `${sqlId(f.property)} BETWEEN ${sqlQ(f.lower)} AND ${sqlQ(f.upper)}`,
    'in': f => `${sqlId(f.property)} IN (${sqlSep(',', ...f.values)})`,
    'notIn': f => `${sqlId(f.property)} NOT IN (${sqlSep(',', ...f.values)})`,
    'equals': f => sqlSep(' = ', f.left, f.right),
    'notEquals': f => sqlSep(' <> ', f.left, f.right),
    'lessThan': f => sqlSep(' < ', f.left, f.right),
    'lessThanOrEqualTo': f => sqlSep(' <= ', f.left, f.right),
    'greaterThan': f => sqlSep(' > ', f.left, f.right),
    'greaterThanOrEqualTo': f => sqlSep(' >= ', f.left, f.right),
    'property': f => sqlId(f.property),
    'value': f => sqlQ(f.value)
};
