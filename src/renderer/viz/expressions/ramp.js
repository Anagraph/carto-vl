import BaseExpression from './base';
import { implicitCast, checkExpression, checkType, clamp, checkInstance, checkMaxArguments, mix } from './utils';

import { interpolateRGBAinCieLAB, sRGBToCielab } from '../colorspaces';
import NamedColor from './color/NamedColor';
import Buckets from './buckets';
import Property from './basic/property';
import Classifier from './classification/Classifier';
import ImageList from './ImageList';
import Linear from './linear';
import Top from './top';
import CIELabGLSL from './color/CIELab.glsl';
import CategoryIndex from './CategoryIndex';
import { constant } from '../expressions';
import { OTHERS_GLSL_VALUE } from './constants';
import Palette from './color/palettes/Palette';

const DEFAULT_OTHERS_NAME = 'CARTOVL_OTHERS';
const MAX_SAMPLES = 100;
const DEFAULT_SAMPLES = 10;

const DEFAULT_OPTIONS = {
    defaultOthers: DEFAULT_OTHERS_NAME,
    samples: DEFAULT_SAMPLES
};

const paletteTypes = {
    PALETTE: 'palette',
    COLOR_ARRAY: 'color-array',
    NUMBER_ARRAY: 'number-array',
    IMAGE_LIST: 'image-list'
};

const rampTypes = {
    COLOR: 'color',
    NUMBER: 'number'
};

const inputTypes = {
    NUMBER: 'number',
    CATEGORY: 'category'
};

const COLOR_ARRAY_LENGTH = 256;
const MAX_BYTE_VALUE = 255;

/**
* Create a ramp: a mapping between an input (a numeric or categorical expression) and an output (a color palette or a numeric palette, to create bubble maps)
*
* Categories to colors
* Categorical expressions can be used as the input for `ramp` in combination with color palettes. If the number of categories exceeds the number of available colors in the palette new colors will be generated by
* using CieLAB interpolation.
*
* Categories to numeric
* Categorical expression can be used as the input for `ramp` in combination with numeric palettes. If the number of input categories doesn't match the number of numbers in the numeric palette, linear interpolation will be used.
*
* Numeric expressions to colors
* Numeric expressions can be used as the input for `ramp` in combination with color palettes. Colors will be generated by using CieLAB interpolation.
*
* Numeric expressions to numeric
* Numeric expressions can be used as the input for `ramp` in combination with numeric palettes. Linear interpolation will be used to generate intermediate output values.
*
* @param {Number|Category} input - The input expression to give a color
* @param {Palette|Color[]|Number[]} palette - The color palette that is going to be used
* @return {Number|Color}
*
* @example <caption>Mapping categories to colors and numbers</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), [1, 4, 8])
*   color: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), s.palettes.PRISM)
* });
*
* @example <caption>Mapping categories to colors and numbers (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(buckets($dn, [20, 50, 120]), [1, 10,4])
*   color: ramp(buckets($dn, [20, 50, 120]), prism)
* `);
*
*
* @example <caption>Mapping numeric expressions to colors and numbers</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.linear(s.prop('dn'), 40, 100), [1, 8])
*   color: s.ramp(s.linear(s.prop('dn'), 40, 100), s.palettes.PRISM)
* });
*
* @example <caption>Mapping numeric expressions to colors and numbers (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(linear($dn, 40, 100), [1, 10,4])
*   color: ramp(linear($dn, 40, 100), prism)
* `);
*
* @memberof carto.expressions
* @name ramp
* @function
* @api
*/
export default class Ramp extends BaseExpression {
    constructor (input, palette, others = 'default') {
        checkMaxArguments(arguments, 3, 'ramp');

        input = implicitCast(input);
        palette = implicitCast(palette);

        checkExpression('ramp', 'input', 0, input);
        checkExpression('ramp', 'palette', 1, palette);

        super({ input, palette });
        this.palette = palette;
        this.others = others; // FIXME, others is not a children
    }

    eval (feature) {
        const index = this._getIndex(feature);

        if (this.palette.type === paletteTypes.NUMBER_ARRAY) {
            return this._evalNumberArray(feature, index);
        }

        const texturePixels = this._computeTextureIfNeeded();
        const { min, max } = this._getMinMax(feature);

        this.palette = this._calcPaletteValues(this.palette);

        const m = (index - min) / (max - min);
        const numValues = texturePixels.length - 1;

        const color = this.type === rampTypes.NUMBER
            ? this._getValue(texturePixels, numValues, m)
            : this._getColorValue(texturePixels, m);

        if (Number.isNaN(color.r) ||
            Number.isNaN(color.g) ||
            Number.isNaN(color.b) ||
            Number.isNaN(color.a)) {
            return null;
        }

        return color;
    }

    _getFeatureIndex (feature) {
        return this.input.eval(feature);
    }

    _getMinMax (feature) {
        const max = this.input.type === inputTypes.CATEGORY
            ? this.input.numCategories - 1
            : 1;

        if (this.input.isA(Linear)) {
            const name = Object.keys(feature)[0];
            const featureMin = _buildFeature(name, this.input.min.eval());
            const featureMax = _buildFeature(name, this.input.max.eval());

            return {
                min: this.input.eval(featureMin),
                max: this.input.eval(featureMax)
            };
        }

        // FIXME
        return { min: 0, max };
    }

    _getIndex (feature) {
        if (this.input.isA(Property)) {
            return this.input.getPropertyId(feature);
        }

        if (this.input.isA(Top)) {
            return this.input.property.getPropertyId(feature);
        }

        return this.input.eval(feature);
    }
    /**
     * Get the value associated with each category
     *
     * @param {object} config - Optional configuration
     * @param {string} config.defaultOthers - Name for other category values. Defaults to 'Others'.
     * @param {number} config.samples - Number of samples for numeric values to be returned. Defaults to 10. The maximum number of samples is 100.
     * @return {object} - { type, data }. 'type' could be category or number. Data is an array of { key, value } objects. 'key' depends on the expression type. 'value' is the result evaluated by the ramp. There is more information in the examples.
     *
     * @example <caption>Get the color associated with each category</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.prop('vehicles'), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend();
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 'Others', value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get the color associated with each category (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp($vehicles, PRISM)
     * Â´);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend();
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 'Others', value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get the image url associated with each category</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   symbol: s.ramp(s.prop('vehicles'), s.imageList([s.BICYCLE, s.CAR, s.BUS]))
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.symbol.getLegend();
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: bicycleImageUrl },
     *   //       { key: 'Car', value: carImageUrl },
     *   //       { key: 'Bus', value: bicycleImageUrl },
     *   //       { key: 'Others', value:  ''}
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get the image url associated with each category (String)</caption>
     * const viz = new carto.Viz(`
     *   symbol: ramp('$vehicles'), imageList([BICYCLE, CAR, BUS]))
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.symbol.getLegend();
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: bicycleImageUrl },
     *   //       { key: 'Car', value: carImageUrl },
     *   //       { key: 'Bus', value: bicycleImageUrl },
     *   //       { key: 'Others', value:  ''}
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get the top 3 categories and set default category name</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.top(s.prop('vehicles')), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend({
     *      defaultOthers: 'Other Vehicles'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get the top 3 categories and set default category name (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(top($vehicles, 5), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend({
     *      defaultOthers: 'Other Vehicles'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get 4 samples for a linear color ramp</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.linear(s.prop('numvehicles'), 1, 100), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend({
     *       samples: 4
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'numvehicles',
     *   //    data: [
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get 4 samples for a linear color ramp (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(linear($numvehicles, 1, 100), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegend({
     *       samples: 4
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'numvehicles',
     *   //    data: [
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 ] },
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 ] },
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 ] }
     *   //     ]
     *   // }
     * });
     *
     * @memberof carto.expressions.Ramp
     * @name getLegend
     * @instance
     * @api
     */
    getLegend (options) {
        const config = Object.assign({}, DEFAULT_OPTIONS, options);
        const type = this.input.type;

        if (config.samples > MAX_SAMPLES) {
            throw new Error(`The maximum number of samples for a legend is ${MAX_SAMPLES}`);
        }

        if (this.input.type === inputTypes.NUMBER) {
            const { data, min, max } = this._getLegendNumeric(config);
            return { type, min, max, data };
        }

        if (this.input.type === inputTypes.CATEGORY) {
            const data = this._getLegendCategories(config);
            return { type, data };
        }
    }

    _getLegendNumeric (config) {
        const name = this.input.getPropertyName();
        const min = this.input.min.eval();
        const max = this.input.max.eval();
        const INC = (max - min) / config.samples;
        const data = [];

        for (let i = min; i < max; i += INC) {
            const feature = _buildFeature(name, i);
            const key = i;
            const value = this.eval(feature);

            data.push({ key, value });
        }

        return { data, min, max };
    }

    _getLegendCategories (config) {
        const name = this.input.getPropertyName();
        const categories = this._metadata.properties[name].categories;
        const maxNumCategories = this.input.numCategories - 1;
        const legend = [];

        for (let i = 0; i <= maxNumCategories; i++) {
            const category = categories[i];

            if (category) {
                const feature = Object.defineProperty({},
                    name,
                    { value: category.name }
                );

                const key = category.name && i < maxNumCategories
                    ? category.name
                    : config.defaultOthers;

                const value = this.eval(feature);
                legend.push({ key, value });
            }
        }

        return legend;
    }

    _evalNumberArray (feature, index) {
        const max = this.input.type === inputTypes.CATEGORY
            ? this.input.numCategories - 1
            : 1;

        const m = index / max;

        for (let i = 0; i < this.palette.elems.length - 1; i++) {
            const rangeMin = i / (this.palette.elems.length - 1);
            const rangeMax = (i + 1) / (this.palette.elems.length - 1);

            if (m > rangeMax) {
                continue;
            }

            const rangeM = (m - rangeMin) / (rangeMax - rangeMin);
            const a = this.palette.elems[i].eval(feature);
            const b = this.palette.elems[i + 1].eval(feature);
            return mix(a, b, clamp(rangeM, 0, 1));
        }

        throw new Error('Unexpected condition on ramp._evalNumberArray()');
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this.type = this.palette.childType;
        if (this.others === 'default') {
            this.others = this.palette.type === 'number-array' ? constant(1) : new NamedColor('gray');
        } else {
            checkType('ramp', 'others', 2, this.palette.childType, this.others);
        }
        if (this.input.isA(Property)) {
            this.input = this.input.type === inputTypes.NUMBER
                ? new Linear(this.input)
                : new CategoryIndex(this.input);

            this.input._bindMetadata(metadata);
        }

        checkType('ramp', 'input', 0, Object.values(inputTypes), this.input);

        if (this.palette.type === paletteTypes.IMAGE_LIST) {
            checkType('ramp', 'input', 0, inputTypes.CATEGORY, this.input);
            checkInstance('ramp', 'palette', 1, ImageList, this.palette);
        }

        this._properties = metadata.properties;
        this._texCategories = null;
        this._GLtexCategories = null;
        this._metadata = metadata;
    }

    _applyToShaderSource (getGLSLforProperty) {
        const input = this.input._applyToShaderSource(getGLSLforProperty);

        let palette;
        let others;
        if (this.palette.isA(Palette)) {
            const subPalette = this.palette.getColors(this.input.numCategories);
            palette = subPalette.colors;
            others = subPalette.othersColor || this.others;
        } else {
            palette = this.palette.elems;
            others = this.others;
        }

        const GLSLPalette = palette.map(color => color._applyToShaderSource(getGLSLforProperty));
        const GLSLOthers = others._applyToShaderSource(getGLSLforProperty);
        // CHECK interpolate when numCats>=colors, discard colors otherwise

        const GLSLBlend = this.palette.type === 'number-array'
            ? this._generateGLSLBlend(GLSLPalette.map(elem => elem.inline))
            : this._generateGLSLBlend(GLSLPalette.map(elem => `sRGBAToCieLAB(${elem.inline})`));
        const inline = `ramp_color${this._uid}(${input.inline})`;
        const preface = `
                    ${CIELabGLSL}
                    ${GLSLPalette.map(elem => elem.preface).join('\n')}
                    ${GLSLOthers.preface}

                    vec4 ramp_color${this._uid}(float x){
                        return x==${OTHERS_GLSL_VALUE}
                            ? ${GLSLOthers.inline}
                            : cielabToSRGBA(${GLSLBlend});
                    }`;

        return { preface: this._prefaceCode(input.preface + preface), inline };
    }

    _generateGLSLBlend (list, index = 0) {
        const currentColor = list[index];

        if (index === list.length - 1) {
            return currentColor;
        }

        const nextBlend = this._generateGLSLBlend(list, index + 1);

        return _mixClampGLSL(currentColor, nextBlend, index, list.length);
    }
}

function _buildFeature (name, value) {
    const enumerable = true;

    return Object.defineProperty({}, name, { value, enumerable });
}

function _mixClampGLSL (currentColor, nextBlend, index, listLength) {
    const min = (index / (listLength - 1)).toFixed(20);
    const max = (1 / (listLength - 1)).toFixed(20);
    const clamp = `clamp((x - ${min})/${max}, 0., 1.)`;

    return `mix(${currentColor}, ${nextBlend}, ${clamp})`;
}
